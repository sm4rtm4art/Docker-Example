# âœ… MULTI-STAGE BUILD - PRODUCTION READY
# This demonstrates Docker multi-stage build best practices

# ==========================================
# Stage 1: Build Environment
# ==========================================
FROM maven:3.8.6-openjdk-17-slim AS builder

# Set metadata for build stage
LABEL stage=builder
LABEL description="Build stage with Maven and JDK"

# Set working directory
WORKDIR /build

# Copy POM first for better dependency caching
# If POM doesn't change, Docker reuses this layer
COPY pom.xml .

# Download dependencies (this layer is cached if POM unchanged)
RUN mvn dependency:go-offline -B

# Copy source code
COPY src ./src

# Build the application
RUN mvn clean package -DskipTests -B

# ==========================================
# Stage 2: Runtime Environment (Final Image)
# ==========================================
FROM openjdk:17-jre-slim AS runtime

# Set metadata for final image
LABEL maintainer="your-email@example.com"
LABEL description="Optimized Spring Boot application - Multi-stage build"
LABEL version="1.0"
LABEL size="~250-300MB"
LABEL security="Good - no build tools, non-root user"

# Install curl for health checks (minimal dependencies)
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl && \
    rm -rf /var/lib/apt/lists/*

# Create non-root user for security
RUN groupadd -r spring && useradd -r -g spring spring

# Set working directory
WORKDIR /app

# Copy JAR from builder stage (KEY: only the final artifact)
COPY --from=builder --chown=spring:spring /build/target/*.jar app.jar

# Switch to non-root user
USER spring:spring

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# Run the application
ENTRYPOINT ["java", "-jar", "app.jar"]